------------------------------------------FUNDAMENTOS DO NEXT.JS----------------------------------------------------------------------------------------------------------------------
##ESTRUTURA DA APLICAÇÃO
-- Criação do projeto (e paralelamente conectando ao GitHub)
.yarn create next-app [nome do projeto]
.cd [nome do projeto]
.yarn dev (o yarn start nesse caso é para produção)
.commit inicial para subir o repositório no GitHub

next: 10.0.9
react: 17.0.1
react-dom: 17.0.1 (versões utilizadas pelo Diego)

-- Iniciando a criação do projeto Ignews 2.0
.arquivo Index.js é um componente chamado Home (homepage da nossa aplicação)
.Cada arquivo dentro da pasta Pages, acaba virando uma rota, menos o arquivo _app e _document. 
Arquivo chamado index, naturalmente será o arquivo principal da aplicação.

-- Adicionando typescript
.yarn add typescript @types/react @types/node -D
.Show, agora é trocar o nome dos arquivos p/ extensão do ts

-- Estilização com SASS
.Pasta styles - module.css é scoped
.Para utilizar junto, é necessária a instalação do sass [yarn add sass]. Com isso, é necessário 
trocar a nomeação do arquivo para home.module.scss e daí é possível utilizar o método cascata

-- Configuração externa
.file system rooting 
. O _app (MyApp) é o componente que fica 'por fora' de todas as páginas. Se quisermos algo que se repita em todas as páginas
colocaremos dentro desse arquivo. Ele vai ser recarregado toda vez que o usuário troca de página.
. O _document funciona de forma semelhante ao _app, porém, ele só é carregado uma única vez.
Ele pode ser comparado com o index.html no react.app

-- Title dinâmico por página
.Com a tag Head do 'next/head', é possível adicionar um <title> para qualquer página, diretamente do seu arquivo, e que
diretamente irá anexar à página principal. Dentro dessa <Head> é possível colocar <meta>'s e tudo mais. 
.A partir disso, é preciso colocá-los dentro de um react fragment.

-- Estilo Global da aplicação (interfere em toda aplicação)
.Mudança do nome do arquivo para global.scss -> chakra ui é bom nessa ajuda para cores 
. CSS NÃO pode importar dentro do document, porque o _document não tá pronto ainda para compilar css


##COMPONENTES E PÁGINAS
-- Componente Header
. O Next, nas páginas, nos obriga a utilizar o default para exportação, mas no caso dos componentes não iremos utilizar.
. O header fica por volta de tudo, já o div fica por volta do conteúdo "dentro" do header.
. As imagens no Next fica sempre dentro da pasta public, importando com o esquema padrão de '/'.
. Como o Header aparecerá em todas as páginas da aplicação, é de se colocar no arquivo _app.tsx

-- Componente SignIn 
. É interessante fazer outro arquivo, pois o seu funcionamento 'não interfere' no restante dos componentes do Header. 
Seu comportamento é isolado. Ao mudar, ele precisa ser renderizado novamente. Se ele estivesse conectado ao restante,
todos precisariam recarregar. 
. yarn add react-icons (utilizar o font awesome)
. A estilização da margin (left) do botão é no componente Header, pois ele está relacionado com os componentes desse componente
e não solto pela aplicação.

-- Página Home
. O botão subscribe now também será feito em um componente separado, porque terá conexão 
com o stripe para pagamentos e tudo mais, então com esse commit foi concluída a página home da
aplicação

-- Subscribe Button
. É o contexto que define os espaçamentos dentro dos elementos dentro dele.


## INTEGRAÇÃO COM API (STRIPE)
-- Configurando Stripe 
. Plataforma para pagamentos com cartão de crédito, com ambiente de homolagação bem rápido.
. A publishable key (desenvolvedores - chaves da API) é uma chave que é utilizada quando precisamos interagir com a 
API do stripe através do nosso frontend (para informações públicas)
. A secret key é [obviamente privada], com isso, caso em mãos erradas, a pessoa pode fazer de tudo na conta stripe,
até deletar os dados gerais da conta, por exemplo.

. .env.local - arquivo de variáveis ambiente, variáveis que são diferentes de acordo com o ambiente que a aplicação está 
rodando. Online, em testes, variando. 

-- Consumindo API do Stripe (SSR - Server-side Rendering)
. Realizar a primeira chamada pra API do Stripe, para obter as infos do produto que criamos.
. Ao usuário clicar em subscribe, eu preciso ter a referência de qual produto eu quero inscrever o usuário. Buscar esse
produto assim que a página for renderizada. (layout shit - mudança de layout que pode ser percebida pelo usuário)
. Quando eu quero fazer uma chamada API via SSR e não no Cliente Side R., dentro de uma página do Next (eu preciso repassar a informação 
da página AO componente)
. O nome da função PRECISA ser getServerSideProps, não pode ser de outra forma. Foi escrita em formato de const, porque dentro
do Next conseguimos importar uma tipagem para essa função, chamada getServerSideProps
. Se retornarmos/passarmos uma propriedade (por exemplo: props { nome: 'Fulano'}), conseguimos acessar o nome do usuário 
através das props na Home, (console.log)
. Se o console.log estivesse dentro do getServerSideProps, não aparecerá na tela, porque o getServerSideProps é executado
na camada do servidor Node - Next -, e não no browser. Aparecerá, portanto, no console.

. Para começarmos, e fazer a chamada para a API do Stripe, adicionando ela portanto na aplicação [yarn add stripe]
. Com isso, criando uma página services, com um arquivo stripe.ts dentro, arquivo que vai definir a conexão com o Stripe

. A partir disso, vamos utilizar essa API do Stripe para fazer uma requisição (index.tsx): https://stripe.com/docs/api/customers/list?lang=node
await stripe.prices.retrieve() o retrieve é porque é apenas um preço, dai ali dentro vamos passar o id do preço -> indo 
no produtos do stripe, clicar no próprio produto e copiar o api_id do PRICE, não do PRODUCT.
. Em seguida passamos outro argumento chamado expand['product'], pois queremos as informações do produto. Pode-se analisar
pela documentação aqui: https://stripe.com/docs/api/prices/retrieve.
. A criação da const product (produto) é para nos fornecer os dados que precisamos do produto. O link acima mostra o nome
das respostas.
. Com isso, podemos passar nosso produto na página. Contudo, antes, precisamos tipar a Home, falando as propriedades que
ele recebe. 
Show, com isso, podemos colocar o amount do produto diretamente no span.
. Agora, vale formatar o número do preço, para ficar com a sigla da moeda e tudo mais.

. Ok, agora, precisaremos do PriceId que sobrou la no SubscribeButton, passando ele no SubscribeButton da Homepage
. Como não iremos utilizar os dados do produto no momento, podemos excluir ,{expand: ['product']} do const price. Se quisermos
mostrar o nome do produto, descrição dele e tudo mais, só fazer isso. Daí, dentro do price vai ter o nome do produto e tudo mais
price.product.blabla

-- Static Site Generation (SSG)
. Se 1 milhão de usuários acessarem a página, 1 mi de vezes irá acontecer a chamada para o stripe e tudo mais. Como só estamos
buscando o preço dos produtos e ele varia geralmente de mês em mês (no máx a cada 24hs), podemos usar o SSG para enviar
o HTML estático já pronto para o usuário.
. Com isso, podemos mudar de getServerSideProps para getStaticProps (index.tsx). O conteúdo é o mesmo para todos os usuários
que irão logar. Portanto, se tiver uma mensagem com "Olá Fulano", todos irão ler, mesmo quem se chama 'Ciclano'.
. 3 principais formas de fazer uma chamada: 
    Client-side
    Server-side
    Static Site Generation
. Um bom exemplo foi: Para uma post de Blog por exemplo
    Conteúdo (SSG)
    Comentários (Client-side)

------------------------------------------BACKEND NO FRONTEND----------------------------------------------------------------------------------------------------------------------
##API ROUTES NO NEXT.JS
-- API routes no Next.js
. File System Rooting, os arquivos dentro de pages viram páginas na nossa aplicação, menos o _app e _document.
. Todos os arquivos que criarmos dentro dessa pasta api (criada dentro de pages), virarão rotas na nossa aplicação. 
Cada arquivo vai se tornar numa rota do nosso backend (trazendo informações para a gente)
. Como não irão mostrar componentes, podemos escrever com a extensão ts e não tsx.
. Dentro das funções geralmente se recebem 2 parâmetros, request e response. O request são todos os dados da nossa requisição
Criando um dado de usuário, dentro do request teremos os dados dele. O response é, claro, a resposta. Se estamos querendo
a listagem de usuário, a resposta é uma listagem de usuário (do formato JSON).

-- Estratégias de autenticação
. Métodos de autenticação disponíveis no Next: JWT (Storage) / Next Auth (Social) / Cognito, Auth0
. Nessa aplicação, será utilizado o modelo Next Auth, já tem suporte para fazer autenticação com o GitHub de forma simples
e login de forma automática e mais fácil.
. Documentação: https://next-auth.js.org/providers/github

-- Parametrização nas rotas
. Para uma rota em que se possa receber parâmetros, como nessa aplicação buscar o usuário pelo Id, podemos colocar o nome
do arquivo como [id].tsx
. //localhost:3000/api/users/1, retorna no console os parâmetros
. Com o spread operator nos params, a partir do console.log(request.query), tudo passado após o users, vai vir dentro do
request.query
. Esse método é muito utilizado para fazer a integração com alguma coisa terceira. Para fazer a autenticação, é importante
para não precisar fazer vários tipos de rotas diferentes (um arquivo para cada tipo de autenticação)
